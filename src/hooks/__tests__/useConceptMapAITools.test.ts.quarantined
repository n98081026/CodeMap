import { act, renderHook } from '@testing-library/react';
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import type { Mock } from 'vitest';

import { useConceptMapAITools } from '../useConceptMapAITools';
import * as aiFlows from '@/ai/flows';
import { useToast } from '@/hooks/use-toast';
import { useConceptMapStore } from '@/stores/concept-map-store';
import type { ConceptMapNode } from '@/types';

// --- Mocks ---
// By creating a __mocks__ directory adjacent to the store, Vitest's `vi.mock`
// will automatically pick up our manual mock instead of the real store.
// This is the most robust way to mock complex modules.
vi.mock('@/stores/concept-map-store');
vi.mock('@/ai/flows', () => ({
  runFlow: vi.fn(),
}));
vi.mock('@/hooks/use-toast', () => ({
  useToast: vi.fn(),
}));

const toast = vi.fn().mockReturnValue({ id: 'toast-id' });

describe('useConceptMapAITools', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    (useToast as Mock).mockReturnValue({ toast });
  });

  describe('handleExtractConcepts', () => {
    it('should call extractConcepts flow and stage data on success', async () => {
      // Arrange
      const mockExtractedData = {
        concepts: [{ text: 'concept1', reason: 'reason1' }],
      };
      vi.mocked(aiFlows.runFlow).mockResolvedValue(mockExtractedData);

      // We need to get a handle on the mocked functions from our manual mock.
      // We can do this by importing the store and accessing the vi.fn() instances.
      const { setStagedMapData } = useConceptMapStore();

      const { result } = renderHook(() => useConceptMapAITools());

      // Act
      await act(async () => {
        await result.current.handleExtractConcepts({ context: 'some context' });
      });

      // Assert
      expect(aiFlows.runFlow).toHaveBeenCalledWith('extractConcepts', { context: 'some context' });
      expect(setStagedMapData).toHaveBeenCalled();
      const stagedData = (setStagedMapData as Mock).mock.calls[0][0];
      expect(stagedData.nodes[0].text).toBe('concept1');
      expect(stagedData.actionType).toBe('extractConcepts');

      expect(toast).toHaveBeenCalledWith(expect.objectContaining({ title: 'AI Processing...' }));
      expect(toast).toHaveBeenCalledWith(expect.objectContaining({ title: 'Concepts Extracted' }));
    });

    it('should show an error toast on failure', async () => {
      // Arrange
      const error = new Error('AI extraction failed');
      vi.mocked(aiFlows.runFlow).mockRejectedValue(error);
      const { setStagedMapData } = useConceptMapStore();
      const { result } = renderHook(() => useConceptMapAITools());

      // Act
      await act(async () => {
        await result.current.handleExtractConcepts({ context: 'some context' });
      });

      // Assert
      expect(aiFlows.runFlow).toHaveBeenCalledWith('extractConcepts', { context: 'some context' });
      expect(setStagedMapData).not.toHaveBeenCalled();
      expect(toast).toHaveBeenCalledWith(expect.objectContaining({
        title: 'Error Extracting Concepts',
        description: error.message,
        variant: 'destructive',
      }));
    });
  });
});
