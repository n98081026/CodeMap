
"use client";
import React, { memo, useEffect, useRef, useState } from 'react';
import { Handle, Position, type NodeProps } from 'reactflow';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';
import useConceptMapStore from '@/stores/concept-map-store';
import {
  Box, Milestone, ServerCog, MonitorPlay, Database, FileCode2, ExternalLink, Users, Workflow,
  Brain, Lightbulb, Puzzle, AlignLeft, PenLine, PlusCircle, Loader2, Sparkles
} from 'lucide-react';
import { getNodePlacement } from '@/lib/layout-utils';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";

export interface CustomNodeData {
  label: string;
  details?: string;
  type?: string; // e.g., 'key_feature', 'service_component', 'ai-generated', etc.
  isViewOnly?: boolean;
  backgroundColor?: string; // Allow individual node background color
  shape?: 'rectangle' | 'ellipse'; // Allow shape customization
  width?: number; // Explicit width from store
  height?: number; // Explicit height from store
  onTriggerAIExpand?: (nodeId: string) => void; // Callback for AI expand button
}

const NODE_TYPE_ICONS: { [key: string]: React.ElementType } = {
  key_feature: Milestone,
  service_component: ServerCog,
  ui_view: MonitorPlay,
  data_model: Database,
  code_module: FileCode2,
  external_dependency: ExternalLink,
  user_role: Users,
  core_process: Workflow,
  'ai-generated': Brain, // For generic AI-generated nodes
  'ai-concept': Lightbulb, // From Extract Concepts or Suggest Relations
  'text-derived-concept': Puzzle, // From Generate Snippet
  'ai-summary-node': AlignLeft, // From Summarize Selection
  'ai-rewritten-node': PenLine, // From Rewrite Content
  'ai-expanded': Sparkles, // For nodes directly generated by "Expand Concept"
  default: Box,
};

const CustomNodeComponent: React.FC<NodeProps<CustomNodeData>> = ({ data, id, selected, xPos, yPos }) => {
  const {
    editingNodeId, setEditingNodeId, updateNode,
    addNode: addStoreNode, addEdge: addStoreEdge,
    aiProcessingNodeId, isViewOnlyMode: globalIsViewOnlyMode
  } = useConceptMapStore();

  const isCurrentNodeEditing = editingNodeId === id && !data.isViewOnly && !globalIsViewOnlyMode;
  const inputRef = useRef<HTMLInputElement>(null);
  const detailsRef = useRef<HTMLTextAreaElement>(null);
  const [isHovered, setIsHovered] = useState(false);
  const [tempLabel, setTempLabel] = useState(data.label);

  const nodeIsViewOnly = data.isViewOnly || globalIsViewOnlyMode;
  const isCurrentNodeProcessingAI = aiProcessingNodeId === id;

  useEffect(() => {
    setTempLabel(data.label); // Sync tempLabel when data.label changes externally
  }, [data.label]);

  useEffect(() => {
    if (isCurrentNodeEditing && inputRef.current) {
      inputRef.current.focus();
      input_ref_select_all(inputRef.current);
    }
  }, [isCurrentNodeEditing]);

  // Helper function to select all text in an input
  const input_ref_select_all = (input_element: HTMLInputElement | HTMLTextAreaElement | null) => {
    if (input_element) {
      input_element.select();
    }
  };

  const handleLabelChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setTempLabel(e.target.value);
    if (!data.width && !data.height) { // Only auto-adjust if no explicit dimensions
      updateNode(id, { text: e.target.value }); // Update store for auto-sizing in real-time
    }
  };

  const handleLabelEditCommit = () => {
    updateNode(id, { text: tempLabel });
    setEditingNodeId(null);
  };

  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    if (e.key === 'Enter' && !(e.shiftKey && e.currentTarget.tagName === 'TEXTAREA')) {
      e.preventDefault(); // Prevent new line in input, allow in textarea with Shift+Enter
      handleLabelEditCommit();
      if (e.currentTarget.tagName === 'TEXTAREA' && detailsRef.current) {
        detailsRef.current.blur(); // Commit textarea on Enter without Shift
      }
    }
    if (e.key === 'Escape') {
      setTempLabel(data.label); // Revert to original label on Escape
      setEditingNodeId(null);
    }
  };

  const NodeIcon = NODE_TYPE_ICONS[data.type || 'default'] || NODE_TYPE_ICONS.default;

  const cardClasses = cn(
    "shadow-lg rounded-lg border-2 transition-all duration-150 ease-in-out group nodrag relative",
    selected ? "border-primary ring-2 ring-primary shadow-2xl" : "border-border",
    data.shape === 'ellipse' && '!rounded-full',
    nodeIsViewOnly && "cursor-default",
    !nodeIsViewOnly && "cursor-grab",
    isCurrentNodeProcessingAI && "opacity-70 ring-2 ring-offset-2 ring-purple-500 animate-pulse"
  );

  const cardStyle: React.CSSProperties = {
    backgroundColor: data.backgroundColor || undefined, // Use theme default if not set
    width: data.width ? `${data.width}px` : 'auto', // explicit or auto
    minWidth: data.width ? `${data.width}px` : '160px', // min if auto
    maxWidth: data.width ? `${data.width}px` : '320px', // max if auto
    height: data.height ? `${data.height}px` : 'auto',
    minHeight: data.height ? `${data.height}px` : (data.shape === 'ellipse' ? (data.width || 160) : 70) + 'px',
    maxHeight: data.height ? `${data.height}px` : '400px', // Max height for auto-sizing details
    display: 'flex',
    flexDirection: 'column',
  };
   if (data.shape === 'ellipse') {
    cardStyle.aspectRatio = '1 / 1';
    if (data.width) cardStyle.height = `${data.width}px`; // Ellipse forced to circle for simplicity if width given
    else if (data.height) cardStyle.width = `${data.height}px`;
    else { // Auto-size ellipse (circle)
        cardStyle.minWidth = '100px'; // Smaller min for circles
        cardStyle.minHeight = '100px';
    }
  }


  const handleCreateChildNode = (direction: 'top' | 'right' | 'bottom' | 'left') => {
    if (nodeIsViewOnly) return;
    const parentNode = useConceptMapStore.getState().mapData.nodes.find(n => n.id === id);
    if (!parentNode) return;

    const currentNodes = useConceptMapStore.getState().mapData.nodes;
    const newPosition = getNodePlacement(currentNodes, 'child', parentNode, null, 20, direction);
    const newNodeId = addStoreNode({
      text: "New Idea",
      type: 'manual-node',
      position: newPosition,
      parentNode: id,
    });
    addStoreEdge({
      source: id,
      target: newNodeId,
      label: 'relates to'
    });
    setEditingNodeId(newNodeId); // Auto-focus new child node
  };

  const plusButtonClass = "absolute bg-primary text-primary-foreground rounded-full p-0.5 hover:bg-primary/80 transition-all transform scale-75 group-hover/node:scale-100 opacity-0 group-hover/node:opacity-100 disabled:opacity-30";

  return (
    <TooltipProvider delayDuration={300}>
      <Card
        className={cardClasses}
        style={cardStyle}
        onMouseEnter={() => setIsHovered(true)}
        onMouseLeave={() => setIsHovered(false)}
        data-shape={data.shape}
        data-node-id={id}
      >
        <CardHeader
            className={cn(
                "flex flex-row items-center space-x-2 p-2 pb-1 cursor-move dragHandle",
                data.shape === 'ellipse' && "justify-center pt-3" // Center icon in ellipse
            )}
        >
          <NodeIcon className="h-4 w-4 text-muted-foreground flex-shrink-0" />
          {isCurrentNodeEditing ? (
            <Input
              ref={inputRef}
              value={tempLabel}
              onChange={handleLabelChange}
              onBlur={handleLabelEditCommit}
              onKeyDown={handleKeyDown}
              className="text-sm font-semibold h-7 px-1 py-0.5 border-primary focus:ring-primary flex-grow min-w-0 bg-background/80"
              disabled={nodeIsViewOnly}
            />
          ) : (
            <CardTitle
              onDoubleClick={() => !nodeIsViewOnly && setEditingNodeId(id)}
              className={cn(
                "text-sm font-semibold leading-tight truncate flex-grow min-w-0",
                !nodeIsViewOnly && "cursor-text",
                 data.shape === 'ellipse' && "text-center"
              )}
            >
              {data.label || "Untitled Node"}
            </CardTitle>
          )}
        </CardHeader>
        {data.details && data.shape !== 'ellipse' && (
          <CardContent className="p-2 pt-0 text-xs text-muted-foreground overflow-y-auto flex-grow min-h-0">
             <div className="whitespace-pre-wrap break-words max-h-[calc(400px-70px)]"> {/* Max height minus header/padding approx */}
                {data.details}
             </div>
          </CardContent>
        )}
         {data.shape === 'ellipse' && data.details && (
             <Tooltip>
                <TooltipTrigger asChild>
                    <div className="text-center text-xs text-muted-foreground px-2 pb-2 truncate cursor-default">
                        (hover for details)
                    </div>
                </TooltipTrigger>
                <TooltipContent side="bottom" className="max-w-xs">
                    <p className="text-xs whitespace-pre-wrap break-words">{data.details}</p>
                </TooltipContent>
             </Tooltip>
         )}

        {/* Connection Handles */}
        <Handle type="source" position={Position.Top} id={`${id}-top-source`} className="react-flow__handle-custom !-top-1" isConnectable={!nodeIsViewOnly} />
        <Handle type="target" position={Position.Top} id={`${id}-top-target`} className="react-flow__handle-custom !-top-1" isConnectable={!nodeIsViewOnly} />
        <Handle type="source" position={Position.Right} id={`${id}-right-source`} className="react-flow__handle-custom !-right-1" isConnectable={!nodeIsViewOnly} />
        <Handle type="target" position={Position.Right} id={`${id}-right-target`} className="react-flow__handle-custom !-right-1" isConnectable={!nodeIsViewOnly} />
        <Handle type="source" position={Position.Bottom} id={`${id}-bottom-source`} className="react-flow__handle-custom !-bottom-1" isConnectable={!nodeIsViewOnly} />
        <Handle type="target" position={Position.Bottom} id={`${id}-bottom-target`} className="react-flow__handle-custom !-bottom-1" isConnectable={!nodeIsViewOnly} />
        <Handle type="source" position={Position.Left} id={`${id}-left-source`} className="react-flow__handle-custom !-left-1" isConnectable={!nodeIsViewOnly} />
        <Handle type="target" position={Position.Left} id={`${id}-left-target`} className="react-flow__handle-custom !-left-1" isConnectable={!nodeIsViewOnly} />

        {/* AI Processing Spinner */}
        {isCurrentNodeProcessingAI && (
            <div className={cn(
                "absolute inset-0 flex items-center justify-center bg-background/50 backdrop-blur-sm",
                data.shape === 'ellipse' ? 'rounded-full' : 'rounded-lg'
            )}>
                <Loader2 className="h-6 w-6 animate-spin text-purple-500" />
            </div>
        )}

        {/* "+" Hover Buttons for Child Node Creation */}
        {!nodeIsViewOnly && isHovered && !isCurrentNodeProcessingAI && (
          <>
            {/* Top */}
            <Tooltip>
              <TooltipTrigger asChild>
                <Button onClick={() => handleCreateChildNode('top')} className={cn(plusButtonClass, "top-0 left-1/2 -translate-x-1/2 -translate-y-1/2")} disabled={nodeIsViewOnly}>
                  <PlusCircle className="h-4 w-4" />
                </Button>
              </TooltipTrigger>
              <TooltipContent side="top"><p>Add child node above</p></TooltipContent>
            </Tooltip>
            {/* Right */}
            <Tooltip>
              <TooltipTrigger asChild>
                 <Button onClick={() => handleCreateChildNode('right')} className={cn(plusButtonClass, "top-1/2 right-0 -translate-y-1/2 translate-x-1/2")} disabled={nodeIsViewOnly}>
                  <PlusCircle className="h-4 w-4" />
                </Button>
              </TooltipTrigger>
              <TooltipContent side="right"><p>Add child node to the right</p></TooltipContent>
            </Tooltip>
            {/* Bottom */}
             <Tooltip>
              <TooltipTrigger asChild>
                <Button onClick={() => handleCreateChildNode('bottom')} className={cn(plusButtonClass, "bottom-0 left-1/2 -translate-x-1/2 translate-y-1/2")} disabled={nodeIsViewOnly}>
                  <PlusCircle className="h-4 w-4" />
                </Button>
              </TooltipTrigger>
              <TooltipContent side="bottom"><p>Add child node below</p></TooltipContent>
            </Tooltip>
            {/* Left */}
            <Tooltip>
              <TooltipTrigger asChild>
                <Button onClick={() => handleCreateChildNode('left')} className={cn(plusButtonClass, "top-1/2 left-0 -translate-y-1/2 -translate-x-1/2")} disabled={nodeIsViewOnly}>
                  <PlusCircle className="h-4 w-4" />
                </Button>
              </TooltipTrigger>
              <TooltipContent side="left"><p>Add child node to the left</p></TooltipContent>
            </Tooltip>
          </>
        )}
         {/* AI Expand Button - visible on hover if node selected and not view only */}
        {!nodeIsViewOnly && selected && data.onTriggerAIExpand && !isCurrentNodeProcessingAI && (
           <Tooltip>
            <TooltipTrigger asChild>
                <Button
                    variant="ghost"
                    size="icon"
                    className={cn(
                        "absolute p-1 transition-all",
                        "opacity-50 group-hover/node:opacity-100 hover:!opacity-100",
                        "focus:opacity-100",
                        data.shape === 'ellipse' ? 'top-1 right-1 h-6 w-6' : 'bottom-1 right-1 h-7 w-7'
                    )}
                    onClick={(e) => { e.stopPropagation(); data.onTriggerAIExpand?.(id); }}
                    disabled={nodeIsViewOnly}
                >
                    <Sparkles className="h-4 w-4 text-purple-500" />
                </Button>
            </TooltipTrigger>
            <TooltipContent side="top" align="end" className="text-xs">
                <p>Expand with AI</p>
                <p className="text-muted-foreground">(Generates related child nodes)</p>
            </TooltipContent>
           </Tooltip>
        )}
      </Card>
    </TooltipProvider>
  );
};

export default memo(CustomNodeComponent);

    